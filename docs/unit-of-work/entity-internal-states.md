# Entity Internal States

The role of Unit of Work is to track changes in entities. In order to do so each entity needs to be registered in
Unit of Work. But how does it know which of them are new, which updated and which are deleted?

By the definition entity is an object that can be identified. (That is why you can only register entities in Unit of Work)

This simple definition allows Unit of Work to recognize 4 different states of entity.
All of them are described in internal UnitOfWork class ``EntityStates``
```php
<?php

namespace Isolate\UnitOfWork;

final class EntityStates
{
    /**
     * New created entity that was not persisted yet
     */
    const NEW_ENTITY = 0;

    /**
     * Persisted entity
     */
    const PERSISTED_ENTITY = 1;

    /**
     * Persisted object that was saved to data source in past but it was
     * modified after registration in unit of work.
     */
    const EDITED_ENTITY = 2;

    /**
     * Persisted entity that should be deleted
     */
    const REMOVED_ENTITY = 3;
}
```

```EntityStates::NEW_ENTITY``` - it means that entity was just created (for example by a factory) and was never saved in storage
which means it does not have identity yet (or the identity was set only on client side).

```EntityStates::PERSISTED_ENTITY``` - it means that entity was already saved in storage and it was reconstituted from storage
(for example by a repository).

```EntityStates::EDITED_ENTITY``` - it means that entity was registered in UnitOfWork as EntityStates::PERSISTED_ENTITY but
after registration some changes has been done on that entity.

```EntityStates::REMOVED_ENTITY``` - it means that entity was registered in UnitOfWork as EntityStates::PERSISTED_ENTITY but
client decided to remove this entity so its marked in Unit of Work as "to remove".

So basically there are only few simple rules that describe entity lifecycle:

- ``NEW_ENTITY`` **will** become ``PERSISTED_ENTITY`` after commit
- ``NEW_ENTITY`` **can't** become ``REMOVED_ENTITY`` or ``EDITED_ENTITY``
- ``PERSISTED_ENTITY`` **can** become ``EDITED_ENTITY`` or ``REMOVED_ENTITY`` during development
- ``PERSISTED_ENTITY`` **can't** become ``NEW ENTITY``
- ``EDITED_ENTITY`` **will** become ``PERSISTED_ENTITY`` after commit
- ``REMOVED_ENTITY`` **can't** become ``NEW_ENTITY`` or ``PERSISTED_ENTITY``
- ``EDITED_ENTITY`` **can** become ``REMOVED_ENTITY`` if after changes and before commit client decide to remove it
- ``EDITED_ENTITY`` **can't** become ``NEW_ENTITY``

# Entity Identification

As we already know entity is an object that can be identified. What does it means? It means that entity needs to have
at least one property that will contain the unique value that allows to identify this entity from the others.
In most cases it means that Entity will have a private field ``$id`` that will contain unique value (generated by database or
some other mechanism). If this field will be empty then Unit of Work will recognize entity as a ``NEW_ENTITY``

Simple example:

```php
<?php

namespace Application\Domain\Entity;

class User
{
    private $id;

    private $name;

    public function __construct($name)
    {
        $this->name = $name
    }

    public function getName()
    {
        return $this->name;
    }
}
```

For above example it would be enough to create following definition

```php

$definition = new Definition(
    new ClassName("Application\Domain\Entity\User"),
    new Definition\Identity("id")
);

```
It does not matter that there is no public getId method. UnitOfWork will take identity even if property is not accessible.

> **Important:** You need to remember that inside of ``NewCommandHandler`` you need to assign value to the $id property.
> In other case when you execute ``$uow->commit()`` twice entity will be each time treated as a new.

But there are cases when unique entity is not generated by storage

# Custom Identification Strategies

Sometimes there are cases when identity is not generated by a storage. For example when we are using [UUID](http://en.wikipedia.org/wiki/Universally_unique_identifier).
UUID can be generated by a client. Or when our entity is identified by an email address (that needs to be unique in the system).
Let's consider such case.

Simple example:

```php
<?php

namespace Application\Domain\Entity;

class User
{
    private $email;

    private $name;

    public function __construct($email, $name)
    {
        $this->email = $email;
        $this->name = $name
    }

    public function getEmail()
    {
        return $this->email;
    }

    public function getName()
    {
        return $this->name;
    }
}
```

As you can see it would be impossible to decide when entity is ``NEW_ENTITY`` or ``PERSISTED_ENTITY`` as email (which is our
identity) is required by the business rules. We can't create User without email but we also does not have any other unique value.
In this situation we need to create **custom identification strategy** that implements

```php
<?php

namespace Isolate\UnitOfWork\Entity\Definition;

interface IdentificationStrategy
{
    /**
     * @param mixed $entity
     * @return boolean
     */
    public function isIdentified($entity);

    /**
     * @param $entity
     * @return mixed
     */
    public function getIdentity($entity);
}
```

Thanks to above interface Unit of Work can be sure about 2 things. If the entity can be identified between other
entities in storage and what is the entity identity.
This is how implementation of custom identification strategy might look

```php
<?php

namespace Application\Isolate\Entity\Definition;

use Application\Domain\Entity\User;

class UserIdentificationStrategy implements IdentificationStrategy
{
    private $client;

    public function __construct(\StorageClient $client)
    {
        $this->client = $client;
    }

    /**
     * @param mixed $entity
     * @return boolean
     */
    public function isIdentified($entity)
    {
        if (!$entity instanceof User) {
            throw new \InvalidArgumentException();
        }

        return $this->hasUserWithEmail($entity->getEmail);
    }

    /**
     * @param $entity
     * @return mixed
     */
    public function getIdentity($entity)
    {
        if (!$entity instanceof User) {
            throw new \InvalidArgumentException();
        }

        return $entity->getEmail();
    }
}
```

And the entity definition

```php
$storage = $this->get('storage');

$definition = new Definition(
    new ClassName("Application\Domain\Entity\User"),
    new Definition\Identity("id"),
    new UserIdentificationStrategy($storage) // 3rd argument is null by default.
);

```

> **Important:** IdentificationStrategy is executed at least once for each entity registered in Unit of Work during commit.
> It might be wise to identify entity using some different field that does not require storage usage to check if entity
> was already persisted. Sometimes you can use for example ``$createdAt`` field which will hold value only after it will
> successfully saved on storage.
